# Makefile template for Docker images thanks to https://gist.github.com/mpneuried/0594963ad38e68917ef189b4e6a269db
APP_NAME = kube-server
DOCKER_CPUS=$(shell docker info | grep CPUs | awk '{print $$2}')

# Check for dependencies besides docker
EXECUTABLES = minikube curl helm openssl docker kubectl
K := $(foreach exec,$(EXECUTABLES),\
        $(if $(shell which $(exec)),some string,$(error "No $(exec) in PATH")))

# https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html
.PHONY: help

help: ## This help.
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

.DEFAULT_GOAL := help


# DOCKER TASKS
# Build the container
build: ## Build the container
	docker build -t $(APP_NAME) .

build-clean: ## Build the container without caching
	docker build --no-cache -t $(APP_NAME) .

clean: ## cleans certs and binaries
	rm -rf certs/ && \
	rm -rf cmd/kube-server/bin

build-minikube-dev: ## Builds the container with non-compiled project and pushes to minikube
	minikube image build -t $(APP_NAME)-dev:latest -f Dockerfile.dev .

build-minikube: ## Builds the container with the compiled binary
	minikube image build -t $(APP_NAME):latest -f Dockerfile .

create-certs: ## builds the self-signed certs kube-server and redis need
	./scripts/create-certs.sh

go-run-dev: ## go run the server locally with dev parameters
	go run cmd/kube-server/main.go --local --port 8888 --verbose \
	--ca certs/kube-server/ca.crt \
	--cert certs/kube-server/server.crt \
	--key certs/kube-server/server.key \
	--rca certs/redis/redis-ca.crt \
	--rcert certs/redis/redis-client.crt \
	--rkey certs/redis/redis-client.key

# KUBERNETES TASKS
minikube-init: ## Initialize minikube with max cpu and more memory TODO: find MB version of memory in docker info instead hardcode
	minikube start --cpus $(DOCKER_CPUS) \
	--ports="8080:30080,6379:30079,8443:30443"

check-clean: # Make sure you want to proceed
	@echo "This will delete the entire minikube cluster are you sure? [y/n] " && read ans && [ $${ans:-N} == y ]

minikube-clean: check-clean clean ## Clean minikube
	minikube stop ; \
	minikube delete

helm-redis: ## Deploy Redis to minikube
	helm repo add bitnami https://charts.bitnami.com/bitnami && \
	helm upgrade --install redis bitnami/redis --version 16.13.1 --create-namespace --namespace redis \
	--set master.service.type=NodePort \
	--set master.service.nodePorts.redis=30079 \
	--set auth.enabled=false \
	--set tls.enabled="true" \
	--set tls.certificatesSecret="certificates-tls-secret" \
	--set tls.certFilename="server.crt" \
	--set tls.certKeyFilename="server.key" \
	--set tls.certCAFilename="redis-ca.crt" \
	--set tls.autoGenerated="true" \
	--set master.disableCommands=""

helm-redis-dev: ## Deploy Redis to minikube but allows FLUSHALL commands to remove all keys
	helm repo add bitnami https://charts.bitnami.com/bitnami && \
	helm upgrade --install redis bitnami/redis --version 16.13.1 --create-namespace --namespace redis \
	--set master.service.type=NodePort \
	--set master.service.nodePorts.redis=30079 \
	--set auth.enabled=false \
	--set tls.enabled="true" \
	--set tls.certificatesSecret="certificates-tls-secret" \
	--set tls.certFilename="server.crt" \
	--set tls.certKeyFilename="server.key" \
	--set tls.certCAFilename="redis-ca.crt" \
	--set tls.autoGenerated="true" \

helm-local-chart: ## Deploys the local kube-server helm chart
	helm upgrade --install --create-namespace --namespace kube-server -f helm/kube-server/values.yaml kube-server ./helm/kube-server

minikube-init-clean: minikube-clean minikube-init # helm-ingress-nginx ## Recreate minikube

deploy-busybox-testbed: ## Deployment of busybox pods for testing
	kubectl apply -f k8s-manifests/tests.yaml

pre-deploy: ## Steps needed before deploying the kube-server
	kubectl create namespace redis && \
	kubectl create namespace kube-server && \
	kubectl create namespace kube-server-dev

deploy-cert-secrets: ## Deploy cert secrets
	./scripts/deploy-cert-secrets.sh

deploy-test: build-minikube-dev ## Build and launch a pod in minikube with bash shell
	kubectl run --rm -it kube-server-dev --image=$(APP_NAME)-dev:latest \
	--port=8080 --restart=Never -n kube-server-dev --image-pull-policy='Never' \
	/bin/bash

kill-pods: ## Kills all the pods in the kube-server namespace to force pull a new image
	kubectl delete --all pods --namespace kube-server --wait=false

deploy: go-build-linux build-minikube helm-local-chart kill-pods ## Builds the linux binary, builds the docker image, and deploys deploys the kube-server helm chart

deploy-dev: build-minikube-dev ## Makes the Deployment for the kube-server-dev image
	kubectl apply -f k8s-manifests/kube-server-dev-role.yaml && \
	kubectl apply -f k8s-manifests/kube-server-dev.yaml

welcome:
	@echo "\033[0;32mEverything is deployed!"
	@echo "\033[0;33mPlease wait a moment while Redis is starting...\n"
	@echo "\033[0;32mOnce Redis has started, here's some quick commands to test with:"
	@echo "./scripts/client-tls.sh https://localhost:8443/v1/healthz"
	@echo "./scripts/client-tls.sh https://localhost:8443/v1/deployments"
	@echo "./scripts/client-tls.sh https://localhost:8443/v1/replicas/busybox-test/busybox-deployment"
	@echo "./scripts/client-tls.sh -X POST https://localhost:8443/v1/replicas/busybox-test/busybox-deployment -H 'Content-Type: application/json' -d '{"replica_size":5}'"
	@echo "./scripts/client-tls.sh https://localhost:8443/v1/replicas/busybox-test/busybox-deployment \n"
	@echo "Please refer to the docs for a list of endpoints and how to use them \033[0m."

redis-cli:
	redis-cli --tls --insecure --cert certs/redis/redis-client.crt --key certs/redis/redis-client.key --cacert certs/redis/redis-ca.crt

start: go-build-linux minikube-init build-minikube create-certs deploy-busybox-testbed pre-deploy deploy-cert-secrets helm-redis helm-local-chart welcome ## main command that will give you access to kube-server on minikube

start-dev: minikube-init create-certs deploy-busybox-testbed pre-deploy deploy-cert-secrets helm-redis-dev ## This will start you from scratch and allow you to run the kube-server locally

# Go specific
lint: ## uses gofmt TODO: use staticcheck like we have in GHA
	gofmt -w -s -l ./

go-build: ## Build the go application
	cd cmd/kube-server && \
	GOOS=darwin GOARCH=amd64 go build -ldflags="main.Version='development'" -o ./bin/kube-server-mac main.go && \
	cd -

go-build-linux: ## Build the go application with linux support
	cd cmd/kube-server && \
	GOOS=linux GOARCH=amd64 go build -ldflags="main.Version='development'" -o ./bin/kube-server-linux main.go && \
	cd -

# Tests
curl-test: ## Simple curl commands with no validation
	@echo `./scripts/client-tls.sh https://localhost:8443/v1/healthz`
	@echo `./scripts/client-tls.sh https://localhost:8443/v1/deployments`
	@echo `./scripts/client-tls.sh https://localhost:8443/v1/deployments?namespace=busybox-test`
	@echo `./scripts/client-tls.sh https://localhost:8443/v1/replicas/busybox-test/busybox-deployment0`
	@echo `./scripts/client-tls.sh -X POST https://localhost:8443/v1/replicas/busybox-test/busybox-deployment0 -H 'Content-Type: application/json' -d '{"replica_size":5}'`
	@echo `./scripts/client-tls.sh https://localhost:8443/v1/replicas/busybox-test/busybox-deployment0`

int-tests: ## simple Go script for integration testing
	go run tests/client.go \
	--ca certs/kube-server/ca.crt \
    --key certs/kube-server/client.key \
    --cert certs/kube-server/client.crt \

unit-tests: ## unit testing with go test
	go test -v ./...

tests: unit-tests int-tests ## Runs unit and integration tests